
    // public func cost(in tier: QuotaTierType, for level: QuotaTierLevel) -> QuotaTierRate {
    //     guard tier != .local else {
    //         return QuotaTierRate(prognosis: 0, suggestion: 0, base: 0)
    //     }

    //     let cost = travelCost.total()
        
    //     let prog = estimation.travelable(in: tier, for: .prognosis)
    //     let sugg = tier.travelable(using: estimation, for: .suggestion)

    //     let prognosis = Double(prog) * cost
    //     let suggestion = Double(sugg) * cost

    //     let meanSessions = (Double(estimation.prognosis.count) + Double(estimation.suggestion.count)) / 2.0
    //     let meanCost = (prognosis + suggestion) / 2.0
    //     let avgCost = meanCost / meanSessions

    //     return QuotaTierRate(
    //         prognosis: prognosis,
    //         suggestion: suggestion,
    //         base: tier == .combined ? avgCost : cost
    //     )
    // }

    // public func base(for tier: QuotaTierType) -> QuotaTierRate {
    //     let prognosis = estimation.prognosis.double * base 
    //     let suggestion = estimation.suggestion.double * base 

    //     return QuotaTierRate(
    //         prognosis: prognosis,
    //         suggestion: suggestion,
    //         base: base
    //     )
    // }

    // public func price(for tier: QuotaTierType) -> QuotaTierRate {
    //     let cost = cost(for: tier) 
    //     let baseRate = base(for: tier)

    //     let prognosis = baseRate.prognosis + cost.prognosis
    //     let suggestion = baseRate.suggestion + cost.suggestion

    //     let basePrice = baseRate.base + cost.base

    //     return QuotaTierRate(
    //         prognosis: prognosis,
    //         suggestion: suggestion,
    //         base: basePrice
    //     )
    // }

    // public func tier(for tier: QuotaTierType) -> QuotaTierContent {
    //     return QuotaTierContent(
    //         tier: tier,
    //         base: base(for: tier),
    //         cost: cost(for: tier),
    //         price: price(for: tier)
    //     )
    // }
    
    // // only use array for multi-tier
    // public func tiers() -> [QuotaTierContent] {
    //     var tiers: [QuotaTierContent] = []
    //     for t in QuotaTierType.allCases {
    //         tiers.append(tier(for: t))
    //     }
    //     return tiers
    // }




    // per tier we need:
    // the content:
    //      tier: (.local, .combined, .remote)
    //      levels:
    //          prognosis:
    //              price
    //              cost
    //              base
    //          suggestion:
    //              price
    //              cost
    //              base
    //          base (inferred):
    //              price
    //              cost
    //              base

