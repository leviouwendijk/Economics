import Foundation

public enum QuotaTierType: CaseIterable {
    case local
    case combined
    case remote
    // include getting back local count?
}

public struct CustomQuota {
    public let base: Double
    public let travelCost: TravelCost
    public let estimation: SessionCountEstimation

    public init(
        base: Double = 350,
        travelCost: TravelCost,
        estimation: SessionCountEstimation
    ) {
        self.base = base
        self.travelCost = travelCost
        self.estimation = estimation
    }

    public func generate(combinedLocal: Int) -> [QuotaContents] {
        var tiers: [QuotaContents] = []
        for t in QuotaTierType.allCases {
            let cost = travelCost.total()
            var multiplier = 0
            switch t {
                case .local:
                return 0

                case .combined:
                return combinedLocal

                case .remote:
                return 0 // = to suggestion / prognosis

            }


        }
    }
}

// tier: remote
// estimation: prognosis = 5, suggestion = 3
// local: 2 -- if 

public struct QuotaTierPrice {
    public let prognosis: Double
    public let suggestion: Double
    public let base: Double
}

public struct QuotaTierInput {
    public let base: Double
    public let tier: QuotaTierType
    public let estimation: SessionCountEstimation
    
    // private let local: Int {
    //     switch tier {
    //         case .local:
    //         return 

    //     }
    // }

    public init(
        base: Double,
        tier: QuotaTierType,
        estimation: SessionCountEstimation,
    ) {
        self.base = base
        self.tier = tier
        self.estimation = estimation
    }

    public func price() -> QuotaTierPrice {
        return QuotaTierPrice(
            prognosis: estimation.prognosis.double * base,
            suggestion: estimation.suggestion.double * base,
            base: base
        ) 

    }
}


